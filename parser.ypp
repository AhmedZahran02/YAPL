%{ 
    #include <iostream>
    #include <string>
    #include "utils.hpp"
    #include "parser.tab.hpp"

    extern int yylex();
    extern FILE *yyin;   
    void yyerror(const char* s) {
        std::cerr << "Error: " << s << std::endl;
    }
%}

%union  {
    int INum;
    float FNum;
    char character;
    char* str;

    ExpressionNode* ENode;
}


%token <str> IDENTIFIER STRING POW SQRT SHL SHR DATA_TYPE IF ELSE WHILE FOR AND OR GTE LTE LT GT ISEQUAL NOTEQUAL FUNCTIONDEF DO
%token <character> CHARACTER
%token <INum> INTEGER BOOLEAN
%token <FNum> FLOAT

%type <ENode> MathOperand StringOperand MathOperation StringOperation Operation

/* %type <ENode> Operation MathOperand  */

%right IF ELSE
%left '+' '-'
%left SHL SHR GTE LTE LT GT ISEQUAL NOTEQUAL 
%left '^' '&' '|'
%left '*' '/' '%'
%right '['
%left ']'
%left ')'

%start Program
%%

Program: Sentences;

Sentences: Sentence Sentences | ;

Sentence: 
      If_Sentence
    | For_Sentence
    | WhileSentence
    | DoWhileSentence
    | FunctionDefinition
    | VariableDeclaration
    | VariableInitialization

If_Sentence:
      IF '(' MathOperation ')' Scope
    | If_Sentence ELSE If_Sentence
    | If_Sentence ELSE Scope

For_Sentence: 
    FOR '(' IdentifierInit ';' Condition ';' MathOperation ')' Scope

WhileSentence:
    WHILE '(' Condition ')' Scope

DoWhileSentence:
    DO Scope WHILE '(' Condition ')' ';'

FunctionDefinition: 
    FUNCTIONDEF IDENTIFIER '(' FunctionParams ')' Scope

FunctionParams:
    IdentifierDefintion ',' FunctionParams | ;

Scope: '{' Sentences '}'

VariableDeclaration:   
    DATA_TYPE IDENTIFIER

VariableInitialization:
    IDENTIFIER '=' Operation ';'
    VariableDeclaration '=' Operation ';'

IdentifierInit:
    IdentifierDefintion '=' Operation

IdentifierDefintion: DATA_TYPE IDENTIFIER

Condition:
        MathOperation OR MathOperation
    |   MathOperation AND MathOperation
    |   MathOperation GTE MathOperation
    |   MathOperation GT MathOperation
    |   MathOperation LTE MathOperation
    |   MathOperation LT MathOperation
    |   MathOperation ISEQUAL MathOperation
    |   MathOperation NOTEQUAL MathOperation
    
    |   StringOperation GTE StringOperation
    |   StringOperation GT StringOperation
    |   StringOperation LTE StringOperation
    |   StringOperation LT StringOperation
    |   StringOperation ISEQUAL StringOperation
    |   StringOperation NOTEQUAL StringOperation

Operation: MathOperation | StringOperation

MathOperation:
        MathOperation '+' MathOperation     { $$ = &(*($1) + *($3)); }
    |   MathOperation '-' MathOperation     { $$ = &(*$1 - *$3); }  
    |   MathOperation '*' MathOperation     { $$ = &(*$1 * *$3); } 
    |   MathOperation '/' MathOperation     { $$ = &(*$1 / *$3); }    
    |   MathOperation '%' MathOperation     { $$ = &(*$1 % *$3); }     
    |   '(' MathOperation ')' MathOperation { $$ = &(*$2 * *$4); } 
    |   '(' MathOperation ')'           { $$ = &(*$2); }
    |   POW '(' MathOperation ',' MathOperation ')' { $$ = &($3->POW(*$5)); }
    |   SQRT '(' MathOperation ')'      { $$ = &($3->SQRT()); }
    |   MathOperation SHL MathOperation     { $$ = &(*$1 << *$3); } 
    |   MathOperation SHR MathOperation     { $$ = &(*$1 >> *$3); } 
    |   MathOperation '|' MathOperation     { $$ = &(*$1 | *$3); }
    |   MathOperation '&' MathOperation     { $$ = &(*$1 & *$3); }
    |   MathOperation '^' MathOperation     { $$ = &(*$1 ^ *$3); }
    |   MathOperand                    

StringOperation:
        StringOperand '+' StringOperand             { $$ =  $1; }
    |   StringOperand '-' StringOperand             { $$ =  $1; }    
    |   '(' StringOperand ')'                       { $$ =  $2; }
    |   StringOperand '[' INTEGER ':' INTEGER ']'   { $$ =  $1; }
    |   StringOperand SHL StringOperand             { $$ =  $1; } 
    |   StringOperand SHR StringOperand             { $$ =  $1; } 
    |   StringOperand   

MathOperand:
        INTEGER { $$ = ExpressionNode::createIntNode($1);}

        | FLOAT { $$ = ExpressionNode::createFloatNode($1);}

        | CHARACTER { $$ = ExpressionNode::createCharNode($1);}

        | BOOLEAN { $$ = ExpressionNode::createBooleanNode($1);}
    
StringOperand: STRING { $$ = ExpressionNode::createCharNode($1); }

%%


int main() {
    yyin = fopen("test.yapl", "r");
    yyparse();
    return 0;
}